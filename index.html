<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>UMD Course & Commute Planning</title>
  <!-- Leaflet CSS for interactive map -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <!-- Font Awesome for icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
 
  <script async
    src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAS3arcO-QbiYM1cgaxgegiTbBnkM5d-OY&libraries=places,geometry&loading=async&callback=initMap">
  </script>

  <script>
    function initMap() {
      console.log('Google Maps API has loaded.');
      // You can initialize any code that depends on the API here.
      // For instance, you can enable your "Plan Route" button here
      // or simply set a flag indicating that the API is ready.
    }
  </script>

  <style>
    /* AIzaSyAS3arcO-QbiYM1cgaxgegiTbBnkM5d-OY */
    /* Basic reset and styling */
    html, body {  
      margin: 0;
      padding:0;
      font-family: Arial, sans-serif;
      background-color: #ffffff;
      color: #454545;
    }

    :root {
      --default-border: #007bff; /* Using blue for the UMD campus marker */
    }
    /* CUSTOM MARKER BASE */
    .custom-marker {
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      width: 31px;
      height: 31px;
      border-radius: 50%;
      background-color: #ffffff;
      border: 4px solid var(--default-border);
      box-shadow: 0 2px 6px rgba(0,0,0,0.4);
      transition: transform 0.2s;
    }
    /* Triangle pointer */
    .custom-marker::after {
      content: "";
      position: absolute;
      bottom: -10.8px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 12px solid transparent;
      border-right: 12px solid transparent;
      border-top: 10.8px solid var(--default-border);
    }
    /* Icon styling */
    .custom-marker i {
      font-size: 18px;
      color: var(--default-border);
    }
    /* Banner styling */
    .banner {
      width: 100%;
      top: 0;
      left: 0;
      z-index: 5000;
      height: 50px;
      background-color: #e21833;
      color: #ffffff;
      padding: 0 20px;
      box-sizing: border-box;
      display: flex;
      align-items: center;
      justify-content: space-between;
      position: fixed;
    }
    .banner h1 {
      margin: 0;
      font-size: 1em;
      font-weight: 300;
      text-align: left;
    }
    /* Thinner gray footer */
    .footer {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background-color: #7f7f7f;
      color: #ffffff;
      text-align: center;
      padding: 5px 0;
      font-size: 0.85em;
      z-index: 5000;
      box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.2);
    }
    .footer a {
      color: #ffd200;
      text-decoration: none;
    }
    .footer a:hover {
      text-decoration: underline;
    }
    /* Hamburger Menu Icon */
    .menu-icon {
      width: 25px;
      height: 15px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      cursor: pointer;
    }
    .menu-icon span {
      display: block;
      height: 2px;
      background-color: #ffffff;
      border-radius: 2px;
    }
    /* Dropdown Menu Styling */
    .dropdown-menu {
      position: absolute;
      top: 50px;
      right: 0;
      background: #7f7f7f;
      backdrop-filter: blur(5px);
      border: 1px solid #ccc;
      border-radius: 4px;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
      z-index: 10000;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    .dropdown-menu.open {
      opacity: 1;
      visibility: visible;
    }
    .dropdown-menu .menu-item {
      padding: 10px 20px;
      cursor: pointer;
      color: #fff;
    }
    .dropdown-menu .menu-item:hover {
      background-color: rgba(255, 255, 255, 0.15);
    }
    /* Container */
    .container {
      text-align: center;
      max-width: 800px;
      margin: 75px auto 0 auto;
      position: relative;
    }
    .title {
      font-size: 2em;
      font-weight: bold;
      margin-top: 1em;
      color: #e21833;
    }
    .subtitle {
      font-size: 1.1em;
      color: #7f7f7f;
      margin-bottom: 2em;
      font-style: italic;
    }
    .search-prompt {
      font-size: 1.2em;
      margin-bottom: 1em;
      font-weight: bold;
      color: #000;
    }
    .search-container {
      display: flex;
      justify-content: center;
      align-items: center;
      margin-bottom: 2em;
    }
    .term-select, .section-select, .search-input {
      padding: 8px;
      font-size: 16px;
      border: 1px solid #7f7f7f;
      border-radius: 4px;
      background-color: #e6e6e6;
      color: #000;
      height: 42px;
    }
    .term-select {
      margin-right: 10px;
    }
    .section-select {
      margin: 0 10px;
    }
    .input-wrapper {
      position: relative;
      width: 300px;
    }
    .search-input {
      width: 100%;
      box-sizing: border-box;
    }
    .search-input:focus {
      outline: none;
      border-color: #454545;
      box-shadow: 0 0 5px #454545;
    }
    .search-input::selection {
      background: #ffd200;
      color: #000;
    }
    .search-button {
      padding: 10px 20px;
      font-size: 16px;
      background-color: #ffd200;
      color: #000;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      height: 42px;
    }
    .search-button:hover {
      background-color: #e1b600;
    }
    .suggestions {
      position: absolute;
      top: 100%;
      left: 0;
      width: 298px;
      border: 1px solid #7f7f7f;
      border-top: none;
      background: #fdfdfd;
      max-height: 200px;
      overflow-y: auto;
      z-index: 1000;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      border-radius: 4px;
      display: none;
    }
    .suggestion-item {
      padding: 10px;
      cursor: pointer;
      color: #454545;
    }
    .suggestion-item:hover {
      background-color: #dcdcdc;
    }
    #map {
      height: 400px;
      width: 80%;
      max-width: 700px;
      margin: 20px auto;
      border: 1px solid #7f7f7f;
      border-radius: 4px;
    }
    /* Saved Courses container styling */
    #savedCourses {
      position: absolute;
      top: 130px;
      right: -220px;
      width: 200px;
      max-height: 420px;
      overflow-y: auto;
      border: 1px solid #7f7f7f;
      border-radius: 4px;
      background: #fff;
      padding: 10px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      cursor: move;
      z-index: 10000;
      display: none;
    }
    #savedCourses h3 {
      margin: 0;
      font-size: 1.1em;
      color: #e21833;
      text-align: center;
    }
    /* Weekly Schedule container styling */
    #scheduleContainer {
      position: absolute;
      top: 130px;
      left: -300px;
      width: 320px;
      height: 400px;
      overflow-y: hidden;
      border: 1px solid #7f7f7f;
      border-radius: 4px;
      background: #fff;
      padding: 10px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      cursor: move;
      z-index: 10000;
      display: none;
    }
    #scheduleContainer h3 {
      margin-top: 0;
      font-size: 1.1em;
      color: #e21833;
      text-align: center;
    }
    /* Close button for containers */
    .close-btn {
      position: absolute;
      top: 5px;
      left: 15px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      color: #e21833;
    }
    /* Plus button for timed entry */
    .add-btn {
      position: absolute;
      top: 5px;
      right: 15px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      color: #e21833;
    }
    /* Global controls */
    .global-controls {
      display: flex;
      justify-content: center;
      margin-bottom: 8px;
      margin-top: 10px;
    }
    .global-controls button {
      padding: 6px 12px;
      font-size: 0.9em;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      background-color: #ffd200;
      color: #000;
      margin: 0 4px;
    }
    .global-controls button:hover {
      background-color: #e1b600;
    }
    #courseList {
      margin-top: 10px;
    }
    .saved-course-item {
      padding: 5px;
      border: 1px solid #dcdcdc;
      border-radius: 4px;
      margin-bottom: 6px;
      font-size: 0.95em;
      color: #454545;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background-color: #f9f9f9;
    }
    .saved-course-item .course-info {
      display: flex;
      align-items: center;
    }
    .saved-course-item .color-legend {
      display: inline-block;
      width: 12px;
      height: 12px;
      margin-right: 5px;
      border: 1px solid #000;
    }
    .saved-course-item .course-controls {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    #removeAllBtn {
      margin-top: 10px;
      padding: 6px 12px;
      font-size: 0.9em;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      background-color: #ffd200;
      color: #000;
      width: 100%;
    }
    #removeAllBtn:hover {
      background-color: #e1b600;
    }
    /* Weekly schedule grid */
    #scheduleGrid {
      display: grid;
      grid-template-columns: 50px repeat(5, 1fr);
      grid-auto-rows: 30px;
      gap: 1px;
      background-color: #ccc;
      position: relative;
    }
    .day-label {
      background-color: #f5f5f5;
      text-align: center;
      font-weight: bold;
      line-height: 30px;
    }
    .time-label {
      background-color: #f5f5f5;
      text-align: center;
      line-height: 30px;
    }
    .schedule-cell {
      background-color: #fff;
      position: relative;
    }
    /* Base style for schedule blocks */
    .schedule-block {
      position: absolute;
      border-radius: 4px;
      overflow: hidden;
      box-sizing: border-box;
      z-index: 10;
    }
    /* Conflict indicator styling */
    .conflict-indicator {
      position: absolute;
      top: 0;
      right: 0;
      background-color: red;
      color: white;
      font-weight: bold;
      padding: 0 4px;
      font-size: 12px;
      border-bottom-left-radius: 4px;
    }
    /* Timed Entry Window styling */
    .timed-entry-window {
      position: absolute;
      top: 150px;
      left: 150px;
      width: 320px;
      padding: 16px;
      border: 1px solid #7f7f7f;
      background: #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      z-index: 10000;
      display: none;
      border-radius: 8px;
    }
    .timed-entry-window h3 {
      margin-top: 0;
      color: #e21833;
      text-align: center;
      margin-bottom: 12px;
    }
    .timed-entry-window .day-selection {
      display: flex;
      justify-content: space-around;
      margin-bottom: 12px;
    }
    .timed-entry-window .day-selection label {
      display: flex;
      align-items: center;
      font-size: 14px;
      color: #454545;
      cursor: pointer;
    }
    .timed-entry-window .day-selection input {
      margin-right: 4px;
    }
    .timed-entry-window .time-inputs {
      display: flex;
      justify-content: space-between;
      margin-bottom: 12px;
    }
    .timed-entry-window .time-inputs div {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      font-size: 14px;
    }
    .timed-entry-window .time-inputs label {
      margin-bottom: 4px;
      color: #454545;
    }
    .timed-entry-window .time-inputs input {
      padding: 6px;
      border: 1px solid #7f7f7f;
      border-radius: 4px;
      font-size: 14px;
      width: 140px;
    }
    /* Timed entry actions: flipped order and increased gap */
    .timed-entry-window .timed-entry-actions {
      display: flex;
      justify-content: center;
      gap: 10px; /* Adjust the gap as needed */
    }
    
    /* Style the Clear Entry button with UMD red and adjust text color */
    #clearEntryButton {
      background-color: #e21833; /* UMD Red */
      border-color: #e21833;
      color: #ffffff; /* white text for contrast */
    }

    /* Optional: Darker shade on hover for the Clear Entry button */
    #clearEntryButton:hover {
      background-color: #c51120;
    }


    /* Fixed width for both buttons */
    .timed-entry-window .timed-entry-actions button {
      width: 160px; /* Adjust the width as needed */
    }

    .timed-entry-window .timed-entry-actions .search-button {
      font-size: 14px;
      padding: 8px 16px;
    }
    /* --- ROUTE PLANNER STYLING --- */
    #routeContainer {
      display: none; 
      position: absolute; 
      top: 330px; 
      right: -300px; 
      width: 300px; 
      padding: 10px; 
      border: 1px solid #7f7f7f; 
      border-radius: 4px; 
      background: #fff; 
      box-shadow: 0 2px 4px rgba(0,0,0,0.1); 
      z-index: 10000;
      cursor: move;
    }
    .route-title {
      font-size: 1.2em;
      font-weight: bold;
      color: #e21833;
      margin-bottom: 8px;
      text-align: center;
    }
    #closeRoutePlanner {
      position: absolute;
      top: 5px;
      left: 15px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      color: #e21833;
    }
    .transport-modes {
      display: flex;
      justify-content: space-around;
      margin: 10px 0 12px 0;
    }
    .transport-modes i {
      font-size: 18px;
      color: #454545;
      cursor: pointer;
    }
    .transport-modes i:hover {
      color: #e21833;
    }
    .transport-modes i.selected {
      color: #e21833;
    }
    .route-inputs {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 10px;
    }
    .route-inputs input {
      width: 260px;
      padding: 8px;
      border: 1px solid #7f7f7f;
      border-radius: 4px;
      font-size: 14px;
      margin: 0 auto;
    }
    .route-actions {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 280px;
      margin: 0 auto;
      gap: 16px;
    }
    .route-actions button {
      height: 40px;
      flex: 1;
    }
    .location-btn {
      background-color: #f1f1f1;
      border: 1px solid #7f7f7f;
      color: #454545;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: background-color 0.2s ease;
    }
    .location-btn:hover {
      background-color: #e0e0e0;
    }
    .location-btn i {
      margin-right: 6px;
    }
    .plan-route-btn {
      font-size: 14px;
      padding: 8px 12px;
    }
    /* Highlight active route input */
    .active-route-input {
      border-color: #3388ff; /* change color only */
    }
    .leaflet-control-custom:hover {
      background-color: #f4f4f4 !important;
    }

    /* Bus Routes container styling (same as Saved Courses) */
#busRoutesContainer {
  position: absolute;
  top: 130px;
  right: -220px;
  width: 200px;
  max-height: 420px;
  overflow-y: hidden;
  border: 1px solid #7f7f7f;
  border-radius: 4px;
  background: #fff;
  padding: 10px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  cursor: move;
  z-index: 10000;
  display: none;
}

/* Title styling: same as Saved Courses */
#busRoutesContainer h3 {
  margin: 0;
  font-size: 1.1em;
  color: #e21833;
  text-align: center;
}
  
  </style>
</head>
<body>
  <!-- Banner -->
  <div class="banner">
    <h1>University of Maryland</h1>
    <div class="menu-icon" id="menuIcon">
      <span></span>
      <span></span>
      <span></span>
    </div>
    <div class="dropdown-menu" id="dropdownMenu">
      <div class="menu-item" data-target="savedCourses">Saved Courses</div>
      <div class="menu-item" data-target="scheduleContainer">Weekly Schedules</div>
      <div class="menu-item" data-target="routeContainer">Route Planner</div>
      <div class="menu-item" data-target="busRoutesContainer">Bus Routes</div>
    </div>
  </div>
  
  <div class="container">
    <div class="title">UMD Course & Commute Planning</div>
    <div class="subtitle">An interactive platform to help you plan courses and commute options.</div>
    
    <div class="search-prompt">Search for a course</div>
    
    <div class="search-container">
      <select id="termSelect" class="term-select">
        <option value="Spring 2025">Spring 2025</option>
        <option value="Fall 2025" selected>Fall 2025</option>
      </select>
      <div class="input-wrapper">
        <input class="search-input" type="text" placeholder="e.g., CMSC131" id="searchBar" autocomplete="off">
        <div id="suggestions" class="suggestions"></div>
      </div>
      <select id="sectionSelect" class="section-select">
        <option value="">Section</option>
      </select>
      <button class="search-button" id="addBtn">Add</button>
    </div>

    <div class="results" id="resultsContainer"></div>
    <div id="map"></div>

    <!-- Saved Courses container -->
    <div id="savedCourses">
      <div class="close-btn" id="closeSavedCourses">–</div>
      <h3>Saved Courses</h3>
      <div class="global-controls" id="globalControls" style="display: none;">
        <button id="globalToggleBtn">Hide All</button>
      </div>
      <div id="courseList"></div>
      <button id="removeAllBtn" style="display: none;">Remove All</button>
    </div>

    <!-- Weekly Schedule container -->
    <div id="scheduleContainer">
      <div class="close-btn" id="closeSchedule">–</div>
      <div class="add-btn" id="openTimedEntry">+</div>
      <h3>Weekly Schedule</h3>
      <div id="scheduleGrid">
        <div class="time-label"></div>
        <div class="day-label">Mon</div>
        <div class="day-label">Tue</div>
        <div class="day-label">Wed</div>
        <div class="day-label">Thu</div>
        <div class="day-label">Fri</div>
      </div>
    </div>

    <!-- Route Planner container -->
    <div id="routeContainer">
      <div class="close-btn" id="closeRoutePlanner">–</div>
      <div class="route-title">Route Planner</div>
      <div class="transport-modes" id="transportModes">
        <i class="fas fa-car selected" data-mode="drive"></i>
        <i class="fas fa-bus" data-mode="transit"></i>
        <i class="fas fa-walking" data-mode="walking"></i>
        <i class="fas fa-bicycle" data-mode="bicycling"></i>
      </div>
      <div class="route-inputs">
        <input type="text" id="startLocation" placeholder="Choose Start point" autocomplete="off">
        <input type="text" id="endLocation" class="destination-input" placeholder="Choose Destination" autocomplete="off">
      </div>
      <div class="route-actions">
        <button type="button" id="addStop" class="location-btn">
          <i class="fas fa-plus"></i> Add Stop
        </button>
        <button type="button" id="planRouteBtn" class="search-button plan-route-btn">
          Plan Route
        </button>
      </div>
    </div>
    
    <!-- Bus Routes container -->
    <!-- Bus Routes container -->
<div id="busRoutesContainer" style="position: absolute; top: 130px; right: -220px; width: 250px; max-height: 450px; overflow-y: auto; border: 1px solid #7f7f7f; border-radius: 4px; background: #fff; padding: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); cursor: move; z-index: 1000; display: none; text-align: center;">
  <div class="close-btn" id="closeBusRoutes">–</div>
  <h3>Bus Routes</h3>
  <!-- Buttons for Hide All and Show All -->
  <div style="text-align: center; margin: 8px 0;">
    <button id="hideAllRoutes" style="margin-right: 5px; padding: 4px 8px; font-size: 0.9em; width: 90px;">Hide All</button>
    <button id="showAllRoutes" style="padding: 4px 8px; font-size: 0.9em; width: 90px;">Show All</button>
  </div>
  <div id="busRoutesList" style="margin-top: 10px;"></div>

  
</div>
    <!-- Timed Entry Window -->
    <div id="timedEntryWindow" class="timed-entry-window">
      <div class="close-btn" id="closeTimedEntry">×</div>
      <h3>New Timed Entry</h3>
      <form id="timedEntryForm">
        <div class="day-selection">
          <label class="day-label"><input type="checkbox" name="day" value="M"> Mon</label>
          <label class="day-label"><input type="checkbox" name="day" value="Tu"> Tue</label>
          <label class="day-label"><input type="checkbox" name="day" value="W"> Wed</label>
          <label class="day-label"><input type="checkbox" name="day" value="Th"> Thu</label>
          <label class="day-label"><input type="checkbox" name="day" value="F"> Fri</label>
        </div>
        <div class="time-inputs">
          <div>
            <label for="startTime">Start Time:</label>
            <input type="time" id="startTime" name="startTime">
          </div>
          <div>
            <label for="endTime">End Time:</label>
            <input type="time" id="endTime" name="endTime">
          </div>
        </div>
        <!-- Flipped button order with increased gap -->
        <div class="timed-entry-actions">
          <button type="button" id="clearEntryButton" class="search-button">Clear Entry</button>
          <button type="submit" class="search-button">Add Entry</button>
        </div>
      </form>
    </div>
  </div>

  
  
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    // Global variable for active route input.
    let activeRouteInput = null;
    // Global variable for the route polyline.
    let routePolyline = null;
    

    // Instead of clearing activeRouteInput on blur, we only set it on focus.
    const startLocationInput = document.getElementById('startLocation');
    const endLocationInput = document.getElementById('endLocation');
    startLocationInput.addEventListener('focus', function() {
      // Remove highlight from the other input.
      endLocationInput.classList.remove('active-route-input');
      // Set the active input.
      activeRouteInput = startLocationInput;
      startLocationInput.classList.add('active-route-input');
    });

    endLocationInput.addEventListener('focus', function() {
      // Remove highlight from the other input.
      startLocationInput.classList.remove('active-route-input');
      // Set the active input.
      activeRouteInput = endLocationInput;
      endLocationInput.classList.add('active-route-input');
    });
    
    // Clear activeRouteInput if clicking outside the route inputs.
    document.addEventListener('click', function(e) {
      if (!e.target.matches('#startLocation') && !e.target.matches('#endLocation')) {
        if (activeRouteInput) {
          activeRouteInput.classList.remove('active-route-input');
          activeRouteInput = null;
        }
      }
    });

    // Function to handle marker click when a route input is active.
    function markerRouteSelectHandler(e) {
  // Prevent the document click handler from clearing the active input
  e.originalEvent.stopPropagation();
  
  // If no active input, automatically select the first empty destination input
  if (!activeRouteInput) {
    const destinationInputs = document.querySelectorAll('#routeContainer .destination-input');
    for (let input of destinationInputs) {
      if (input.value.trim() === "") {
        activeRouteInput = input;
        input.classList.add('active-route-input');
        break;
      }
    }
  }
  
  // If an active input is set, fill it with the marker's coordinates
  if (activeRouteInput) {
    const latlng = e.latlng;
    activeRouteInput.value = latlng.lat.toFixed(6) + ", " + latlng.lng.toFixed(6);
    activeRouteInput.classList.remove('active-route-input');
    activeRouteInput = null;
  }
}
    
    // Helper function: Calculate the Haversine distance between two coordinates.
    function haversineDistance(coords1, coords2) {
      const R = 6371; // Earth radius in km
      const dLat = (coords2.lat - coords1.lat) * Math.PI / 180;
      const dLng = (coords2.lng - coords1.lng) * Math.PI / 180;
      const lat1 = coords1.lat * Math.PI / 180;
      const lat2 = coords2.lat * Math.PI / 180;
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.sin(dLng/2) * Math.sin(dLng/2) * Math.cos(lat1) * Math.cos(lat2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }
    
    // Variables for route planning
    let routeControl = null;
    let homeMarker = null; // For the "Your location" home marker
    let busRoutesLayers = {};
    
    // Geocode function using Nominatim
    function geocodeAddress(address) {
      return new Promise(function(resolve, reject) {
        L.Control.Geocoder.nominatim().geocode(address, function(results) {
          if (results && results.length > 0) {
            resolve(results[0].center);
          } else {
            reject("Address not found: " + address);
          }
        });
      });
    }
    
    // DOM elements
    const searchBar = document.getElementById('searchBar');
    const addBtn = document.getElementById('addBtn');
    const termSelect = document.getElementById('termSelect');
    const sectionSelect = document.getElementById('sectionSelect');
    const suggestionsDiv = d3.select("#suggestions");
    const resultsContainer = document.getElementById('resultsContainer');
    const savedCoursesDiv = document.getElementById('savedCourses');
    const courseListDiv = document.getElementById('courseList');
    const globalControlsDiv = document.getElementById('globalControls');
    const globalToggleBtn = document.getElementById('globalToggleBtn');
    const removeAllBtn = document.getElementById('removeAllBtn');
    const menuIcon = document.getElementById('menuIcon');
    const dropdownMenu = document.getElementById('dropdownMenu');
    const closeSavedCourses = document.getElementById('closeSavedCourses');
    const closeSchedule = document.getElementById('closeSchedule');
    
    let coursesData = [];
    let currentSections = [];
    let mapCSVData = [];
    
    // Global array to store custom timed entries
    let timedEntries = [];
    
    // Expanded color palette and hex mapping.
    const availableColors = ["red", "gold", "green", "violet", "grey", "yellow", "black", "orange"];
    const colorHexMapping = {
      red: "#CB2B3E",
      gold: "#FFD326",
      green: "#2AAD27",
      violet: "#9C2BCB",
      grey: "#7B7B7B",
      yellow: "#CAC428",
      black: "#3D3D3D",
      orange: "#CB8427"
    };
    let nextColorIndex = 0;
    
    // Global object for course colors
    const courseColorMapping = {};
    let markerZIndexCounter = 1000;
    const addedCourses = new Set();
    const savedCourseMarkerGroups = {};
    const savedSectionsData = {};
    
    // Helper to assign/get icon for courses
    function getCourseIcon(courseId) {
      if (!courseColorMapping[courseId]) {
        courseColorMapping[courseId] = availableColors[nextColorIndex];
        nextColorIndex = (nextColorIndex + 1) % availableColors.length;
      }
      const color = courseColorMapping[courseId];
      const hexColor = colorHexMapping[color] || color;
      return L.divIcon({
        className: '',
        html: `<div class="custom-marker" style="--default-border: ${hexColor};">
                <i class="fa-solid fa-chalkboard-user"></i>
              </div>`,
        iconSize: [40, 52],
        iconAnchor: [20, 52],
        popupAnchor: [0, -52]
      });
    }
    
    // Initialize map
    const map = L.map('map').setView([38.9907, -76.9378], 15);
    var busRouteColorScale = d3.scaleOrdinal().range(d3.quantize(d3.interpolateRainbow, 100));
    
    L.Control.HomeReset = L.Control.extend({
  onAdd: function(map) {
    // Create a container with the Leaflet bar class to stack buttons seamlessly
    var container = L.DomUtil.create('div', 'leaflet-bar');

    // Current Location button (top)
    var locationButton = L.DomUtil.create('a', '', container);
    locationButton.innerHTML = '<i class="fa-solid fa-location-crosshairs"></i>';
    locationButton.title = "Go to Your Current Location";
    locationButton.href = "#";
    L.DomEvent.on(locationButton, 'click', function(e) {
      L.DomEvent.stopPropagation(e);
      L.DomEvent.preventDefault(e);
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(function(position) {
          var lat = position.coords.latitude;
          var lon = position.coords.longitude;
          // Optionally remove an existing marker for current location if needed
          if (window.currentLocationMarker) {
            map.removeLayer(window.currentLocationMarker);
          }
          window.currentLocationMarker = L.marker([lat, lon], {
  icon: L.divIcon({
    className: '',
    html: '<div class="custom-marker" style="--default-border: #3caea3;"><i class="fa-solid fa-user"></i></div>',
    iconSize: [40, 52],
    iconAnchor: [20, 52],
    popupAnchor: [0, -52]
  })
}).addTo(map)
  .on('click', markerRouteSelectHandler)
  .bindPopup("Your Location").openPopup();
          map.setView([lat, lon], 15);
        }, function(error) {
          alert("Unable to retrieve your location.");
        });
      } else {
        alert("Geolocation is not supported by this browser.");
      }
      this.blur();
    });

    // Reset view button (middle, graduation cap)
    var resetButton = L.DomUtil.create('a', '', container);
    resetButton.innerHTML = '<i class="fas fa-graduation-cap"></i>';
    resetButton.title = "Reset to UMD Campus View";
    resetButton.href = "#";
    L.DomEvent.on(resetButton, 'click', function(e) {
  L.DomEvent.stopPropagation(e);
  L.DomEvent.preventDefault(e);
  map.setView([38.9907, -76.9378], 15);
  if (window.campusMarker) {
    window.campusMarker.openPopup();
  }
  this.blur();
});

    // Home button (bottom)
    var homeButton = L.DomUtil.create('a', '', container);
    homeButton.innerHTML = '<i class="fas fa-home"></i>';
    homeButton.title = "Set Home Address";
    homeButton.href = "#";
    L.DomEvent.on(homeButton, 'click', function(e) {
  L.DomEvent.stopPropagation(e);
  L.DomEvent.preventDefault(e);
  
  // If a home marker exists, pan to it first.
  if (window.homeMarker) {
    map.panTo(window.homeMarker.getLatLng());
    window.homeMarker.openPopup(); // Bring up the popup for the home address
    // Ask if the user wants to update their home address.
    var update = confirm("Home address already exists. Would you like to update it?");
    if (!update) {
      this.blur();
      return;
    }
  }
  
  // Prompt for a new home address.
  var homeAddress = prompt("Enter your home address:");
  if (homeAddress) {
    var url = 'https://maps.googleapis.com/maps/api/geocode/json?address=' + encodeURIComponent(homeAddress) + '&key=AIzaSyAS3arcO-QbiYM1cgaxgegiTbBnkM5d-OY';
    fetch(url)
      .then(response => response.json())
      .then(data => {
        if (data.status === "OK" && data.results && data.results.length > 0) {
          var location = data.results[0].geometry.location;
          var lat = parseFloat(location.lat);
          var lon = parseFloat(location.lng);
          if (window.homeMarker) {
            map.removeLayer(window.homeMarker);
          }
          window.homeMarker = L.marker([lat, lon], {
  icon: L.divIcon({
    className: '',
    html: '<div class="custom-marker" style="--default-border: #ad7231;"><i class="fas fa-home"></i></div>',
    iconSize: [40, 52],
    iconAnchor: [20, 52],
    popupAnchor: [0, -52]
  })
}).addTo(map)
  .on('click', markerRouteSelectHandler)
  .bindPopup("Home Address").openPopup();
          map.panTo([lat, lon]);
        } else {
          alert("Address not found!");
        }
      })
      .catch(err => {
        console.error("Geocoding error:", err);
        alert("Error finding the address.");
      });
  }
  this.blur();
});
    return container;
  },
  onRemove: function(map) {
    // Nothing to do here
  }
});

L.control.homeReset = function(opts) {
  return new L.Control.HomeReset(opts);
};

// Add the combined control to the map at the top left
L.control.homeReset({ position: 'topleft' }).addTo(map);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);
    // Campus marker with route select handler attached
    window.campusMarker = L.marker([38.9907, -76.9378], {
      icon: L.divIcon({
        className: '',
        html: `<div class="custom-marker">
                <i class="fas fa-graduation-cap"></i>
              </div>`,
        iconSize: [40, 52],
        iconAnchor: [20, 52],
        popupAnchor: [0, -52]
      })
    }).addTo(map)
      .bindPopup('University of Maryland, College Park')
      .on('click', markerRouteSelectHandler);
    window.campusMarker.openPopup();
    
    let savedMarkers = L.layerGroup().addTo(map);
    let activeMarkers = L.layerGroup().addTo(map);
    
    // Load CSV data
    d3.csv("/data/map.csv").then(data => {
      mapCSVData = data;
      console.log("Loaded map CSV data:", mapCSVData);
    }).catch(error => {
      console.error("Error loading map CSV data:", error);
    });

    let busStopMarkers = {};

    Promise.all([
  d3.csv("./data/umd_bus_stops_details.csv"),
  d3.csv("./data/umd_bus_routes_details.csv")
]).then(([stopsData, routesData]) => {
  // Build bus stops mapping with fallback header names:
  // Try "stop_id", "latitude", "longitude", "stop_name" but fall back to "StopID", "Lat", "Lng", "StopName" if needed.
  // Build bus stops mapping
let busStopsMapping = {};
console.log("Stops data length:", stopsData.length);
stopsData.forEach(row => {
  const stopID = row.stop_id; // Using header "stop_id"
  const lat = parseFloat(row.lat);  // Using header "lat"
  const lng = parseFloat(row.long); // Using header "long"
  const stopTitle = row.stop_title; // Using header "stop_title"
  if (stopID && !isNaN(lat) && !isNaN(lng)) {
    // Use exact matching: trim and convert to lowercase.
    busStopsMapping[stopID.trim().toLowerCase()] = {
      lat: lat,
      lng: lng,
      stop_name: stopTitle
    };
  } else {
    console.warn("Invalid bus stop row:", row);
  }
});
console.log("Bus stops mapping loaded:", busStopsMapping);
  
  // Process bus routes details CSV
  let busRoutesDetailsData = routesData;
  console.log("Loaded bus routes details CSV data:", busRoutesDetailsData);
  
  // Compute unique route IDs and update the color scale for exactly 26 routes
  const uniqueRouteIds = Array.from(new Set(routesData.map(row => row.route_id)));
  busRouteColorScale = d3.scaleOrdinal()
      .domain(uniqueRouteIds)
      .range(d3.quantize(d3.interpolateRainbow, 26));
  
  // Process each bus route: draw the polyline and then place stop markers.
  busRoutesDetailsData.forEach(function(row) {
    // Process route polyline(s)
    if (row.paths && row.paths.trim() !== "") {
      try {
        let parsedPaths = JSON.parse(row.paths.replace(/'/g, '"'));
        if (!busRoutesLayers[row.route_id]) {
          busRoutesLayers[row.route_id] = [];
        }
        if (Array.isArray(parsedPaths)) {
          if (Array.isArray(parsedPaths[0])) {
            parsedPaths.forEach(function(segment) {
              var latlngs = segment.map(coord => [parseFloat(coord.lat), parseFloat(coord.long)])
                .filter(pair => !isNaN(pair[0]) && !isNaN(pair[1]));
              if (latlngs.length > 0) {
                let polyline = L.polyline(latlngs, { color: busRouteColorScale(row.route_id), weight: 4, opacity: 0.9 });
                polyline.addTo(map);
                busRoutesLayers[row.route_id].push(polyline);
              } else {
                console.warn('No valid coordinates in segment for route:', row.route_id);
              }
            });
          } else {
            var latlngs = parsedPaths.map(coord => [parseFloat(coord.lat), parseFloat(coord.long)])
              .filter(pair => !isNaN(pair[0]) && !isNaN(pair[1]));
            if (latlngs.length > 0) {
              let polyline = L.polyline(latlngs, { color: busRouteColorScale(row.route_id), weight: 4, opacity: 0.9 });
              polyline.addTo(map);
              busRoutesLayers[row.route_id].push(polyline);
            } else {
              console.warn('No valid coordinates for route:', row.route_id);
            }
          }
        } else {
          console.warn('Parsed paths is not an array for route:', row.route_id);
        }
      } catch (error) {
        console.error('Error parsing paths for route:', row.route_id, error);
      }
    } else {
      console.warn('No paths data for route:', row.route_id);
    }
    
    if (row.stops && row.stops.trim() !== "") {
  try {
    let stopsArray = JSON.parse(row.stops.replace(/'/g, '"'));
    if (Array.isArray(stopsArray)) {
      stopsArray.forEach(function(stop_id) {
        let lookupKey = stop_id.trim().toLowerCase();
        let stopDetail = busStopsMapping[lookupKey];
        if (stopDetail) {
          // Your existing marker creation code, for example:
          const iconHtml = `<div style="background-color: ${busRouteColorScale(row.route_id)}; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center;">
                              <i class="fa-solid fa-bus" style="color: #ffffff; font-size: 18px;"></i>
                            </div>`;
          const busStopIcon = L.divIcon({
            html: iconHtml,
            className: '',
            iconSize: [30, 30],
            iconAnchor: [15, 15]
          });
          // Create and add the marker:
          const marker = L.marker([stopDetail.lat, stopDetail.lng], { icon: busStopIcon })
            .bindPopup(`<strong>Stop:</strong> ${stopDetail.stop_name || stop_id}<br/><strong>Route:</strong> ${row.route_id}`);
          marker.addTo(map);
          
          // <-- Add the following snippet here:
          if (!busStopMarkers[row.route_id]) {
            busStopMarkers[row.route_id] = [];
          }
          busStopMarkers[row.route_id].push(marker);
          // <-- End of snippet

        } else {
          console.warn("Stop ID '" + lookupKey + "' not found in bus stops details for route:", row.route_id);
        }
      });
    } else {
      console.warn("Stops field is not an array for route:", row.route_id);
    }
  } catch (error) {
    console.error("Error parsing stops for route:", row.route_id, error);
  }
}
  });
  
    // Populate the Bus Routes list in the menu window using the updated color scale
    populateBusRoutesList();
}).catch(error => {
  console.error("Error loading CSV files:", error);
});
    
    // Load courses JSON
    function loadCourses(term) {
      const file = term === "Spring 2025" ? "./data/courses_spring.json" : "./data/courses_fall.json";
      d3.json(file).then(data => {
        coursesData = data;
        console.log("Loaded coursesData for", term, coursesData);
      }).catch(error => {
        console.error("Error loading courses JSON:", error);
      });
    }
    loadCourses(termSelect.value);
    
    let selectedCourse = "";
    termSelect.addEventListener("change", function() {
      loadCourses(this.value);
      sectionSelect.innerHTML = '<option value="">Section</option>';
      selectedCourse = "";
    });
    
    // When the search bar input becomes invalid, reset section, remove schedule preview blocks and clear preview markers.
    searchBar.addEventListener("input", function() {
      const currentText = this.value.trim();
      if (selectedCourse && currentText.indexOf(selectedCourse) === -1) {
        sectionSelect.innerHTML = '<option value="">Section</option>';
        selectedCourse = "";
        removePreviewBlocks();
        activeMarkers.clearLayers(); // Clear preview markers from map
      }
      if (!/^[A-Za-z]+\d+$/.test(currentText)) {
        sectionSelect.innerHTML = '<option value="">Section</option>';
        removePreviewBlocks();
        activeMarkers.clearLayers(); // Clear preview markers from map
      }
    });
    
    function loadSections(courseId) {
      const semester = termSelect.value === "Spring 2025" ? "202501" : "202508";
      const url = `https://api.umd.io/v1/courses/${courseId}/sections?semester=${semester}`;
      d3.json(url).then(data => {
        data.sort((a, b) => {
          let aPart = a.section_id.split('-')[1] || a.section_id;
          let bPart = b.section_id.split('-')[1] || b.section_id;
          return parseInt(aPart) - parseInt(bPart);
        });
        currentSections = data;
        sectionSelect.innerHTML = '<option value="">Section</option>';
        data.forEach(section => {
          const option = document.createElement("option");
          option.value = section.section_id;
          option.textContent = section.section_id.includes('-') ? section.section_id.split('-')[1] : section.section_id;
          sectionSelect.appendChild(option);
        });
        console.log("Loaded and sorted sections for course", courseId, data);
      }).catch(error => {
        console.error("Error loading sections:", error);
      });
    }
    
    // Helper: Parse days string into an array of day tokens.
    function parseDays(daysStr) {
      const days = [];
      let i = 0;
      while (i < daysStr.length) {
        if (daysStr[i] === 'T') {
          if (daysStr[i + 1] === 'h') {
            days.push('Th');
            i += 2;
          } else if (daysStr[i + 1] === 'u') {
            days.push('Tu');
            i += 2;
          } else {
            days.push('Tu');
            i++;
          }
        } else if (daysStr[i] === 'W') {
          days.push('W');
          i++;
        } else if (daysStr[i] === 'F') {
          days.push('F');
          i++;
        } else if (daysStr[i] === 'M') {
          days.push('M');
          i++;
        } else {
          i++;
        }
      }
      return days;
    }
    
    // Helper: Convert "hh:mm" to decimal hours, shifting <7 to PM.
    function parseTime(timeStr) {
      if (!timeStr) return null;
      const parts = timeStr.split(':');
      if (parts.length !== 2) return null;
      let hour = parseInt(parts[0], 10);
      const minute = parseInt(parts[1], 10);
      if (hour < 7) {
        hour += 12;
      }
      return hour + (minute / 60);
    }
    
    // Check if a course section conflicts with any saved course or timed entry.
    function hasTimeConflict(newSection) {
      for (const key in savedSectionsData) {
        const savedSection = savedSectionsData[key];
        for (const newMeeting of newSection.meetings) {
          const newDays = parseDays(newMeeting.days);
          const newStart = parseTime(newMeeting.start_time);
          const newEnd = parseTime(newMeeting.end_time);
          for (const savedMeeting of savedSection.meetings) {
            const savedDays = parseDays(savedMeeting.days);
            const savedStart = parseTime(savedMeeting.start_time);
            const savedEnd = parseTime(savedMeeting.end_time);
            if (newDays.some(day => savedDays.includes(day))) {
              if (newStart < savedEnd && newEnd > savedStart) {
                return true;
              }
            }
          }
        }
      }
      for (const meeting of newSection.meetings) {
        const newDays = parseDays(meeting.days);
        const newStart = parseTime(meeting.start_time);
        const newEnd = parseTime(meeting.end_time);
        for (let entry of timedEntries) {
          const entryDays = parseDays(entry.days);
          const entryStart = parseTime(entry.start_time);
          const entryEnd = parseTime(entry.end_time);
          if (newDays.some(day => entryDays.includes(day))) {
            if (newStart < entryEnd && newEnd > entryStart) {
              return true;
            }
          }
        }
      }
      return false;
    }
    
    // Check conflict for a custom timed entry.
    function hasConflictForTimedEntry(entry) {
      const newDays = parseDays(entry.days);
      const newStart = parseTime(entry.start_time);
      const newEnd = parseTime(entry.end_time);
      for (let key in savedSectionsData) {
        const savedSection = savedSectionsData[key];
        for (let meeting of savedSection.meetings) {
          const savedDays = parseDays(meeting.days);
          const savedStart = parseTime(meeting.start_time);
          const savedEnd = parseTime(meeting.end_time);
          if (newDays.some(day => savedDays.includes(day))) {
            if (newStart < savedEnd && newEnd > savedStart) {
              return true;
            }
          }
        }
      }
      for (let other of timedEntries) {
        if (other === entry) continue;
        const otherDays = parseDays(other.days);
        const otherStart = parseTime(other.start_time);
        const otherEnd = parseTime(other.end_time);
        if (newDays.some(day => otherDays.includes(day))) {
          if (newStart < otherEnd && newEnd > otherStart) {
            return true;
          }
        }
      }
      return false;
    }
    
    // Suggestion dropdown logic
    searchBar.addEventListener("input", function() {
      const query = this.value.trim().toLowerCase();
      if (query === "") {
        suggestionsDiv.style("display", "none");
        return;
      }
      let deptSet = new Set();
      coursesData.forEach(d => {
        let dept = d.dept_id.trim();
        if (dept.toLowerCase().startsWith(query)) {
          deptSet.add(dept);
        }
      });
      const deptSuggestions = Array.from(deptSet);
      if (query.length === 4 && deptSuggestions.includes(query)) {
        const matchingCourses = coursesData.filter(d => d.dept_id.trim().toLowerCase() === query);
        if (matchingCourses.length > 0) {
          const items = suggestionsDiv.selectAll(".suggestion-item")
                                      .data(matchingCourses, d => d.course_id);
          items.exit().remove();
          const newItems = items.enter().append("div")
                                .attr("class", "suggestion-item")
                                .text(d => `${d.course_id} - ${d.name}`)
                                .on("click", (event, d) => {
                                  searchBar.value = d.course_id;
                                  selectedCourse = d.course_id;
                                  suggestionsDiv.style("display", "none");
                                  loadSections(d.course_id);
                                });
          items.merge(newItems)
               .text(d => `${d.course_id} - ${d.name}`);
          suggestionsDiv.style("display", "block");
          return;
        }
      }
      if (query.length < 4 && deptSuggestions.length > 0) {
        const items = suggestionsDiv.selectAll(".suggestion-item")
                                    .data(deptSuggestions, d => d);
        items.exit().remove();
        const newItems = items.enter().append("div")
                              .attr("class", "suggestion-item")
                              .text(d => d)
                              .on("click", (event, d) => {
                                searchBar.value = d;
                                suggestionsDiv.style("display", "none");
                              });
        items.merge(newItems)
             .text(d => d);
        suggestionsDiv.style("display", "block");
        return;
      }
      const filteredCourses = coursesData.filter(d => d.course_id.trim().toLowerCase().startsWith(query));
      if (filteredCourses.length > 0) {
        const items = suggestionsDiv.selectAll(".suggestion-item")
                                    .data(filteredCourses, d => d.course_id);
        items.exit().remove();
        const newItems = items.enter().append("div")
                              .attr("class", "suggestion-item")
                              .text(d => `${d.course_id} - ${d.name}`)
                              .on("click", (event, d) => {
                                searchBar.value = d.course_id;
                                selectedCourse = d.course_id;
                                suggestionsDiv.style("display", "none");
                                loadSections(d.course_id);
                              });
        items.merge(newItems)
             .text(d => `${d.course_id} - ${d.name}`);
        suggestionsDiv.style("display", "block");
      } else {
        suggestionsDiv.style("display", "none");
      }
    });
    
    document.addEventListener("click", function(event) {
      if (!event.target.closest(".search-container") && !event.target.closest("#menuIcon") && !event.target.closest("#dropdownMenu")) {
        suggestionsDiv.style("display", "none");
        dropdownMenu.classList.remove("open");
      }
    });
    
    // When a section is selected, update active markers and show a preview schedule block.
    sectionSelect.addEventListener("change", () => {
      activeMarkers.clearLayers();
      const sectionId = sectionSelect.value;
      if (sectionId) {
        const sectionObj = currentSections.find(s => s.section_id === sectionId);
        if (sectionObj && sectionObj.meetings && sectionObj.meetings.length > 0) {
          const currentCourseId = searchBar.value.trim();
          const courseIcon = getCourseIcon(currentCourseId);
          const meetingsByBuilding = {};
          sectionObj.meetings.forEach(meeting => {
            if (!meetingsByBuilding[meeting.building]) {
              meetingsByBuilding[meeting.building] = [];
            }
            meetingsByBuilding[meeting.building].push(meeting);
          });
          Object.keys(meetingsByBuilding).forEach(buildingCode => {
            const meetings = meetingsByBuilding[buildingCode];
            const buildingRow = mapCSVData.find(b => b.code === buildingCode);
            if (buildingRow) {
              const baseLat = parseFloat(buildingRow.lat);
              const baseLng = parseFloat(buildingRow.long);
              meetings.forEach((meeting, index) => {
                let markerLat = baseLat;
                let markerLng = baseLng;
                if (meetings.length > 1) {
                  const offset = 0.00005 * (index - (meetings.length - 1) / 2);
                  markerLng = baseLng + offset;
                }
                const popupContent = `
                  <strong>${meeting.classtype.trim() === "" ? "Lecture" : meeting.classtype}</strong><br>
                  <em>Days:</em> ${meeting.days}<br>
                  <em>Room:</em> ${meeting.room}<br>
                  <em>Building:</em> ${meeting.building}<br>
                  <em>Start Time:</em> ${meeting.start_time}<br>
                  <em>End Time:</em> ${meeting.end_time}
                `;
                // Add marker for the building with route selection capability
                L.marker([markerLat, markerLng], {
                  icon: courseIcon,
                  zIndexOffset: markerZIndexCounter++
                }).addTo(activeMarkers)
                  .bindPopup(popupContent)
                  .on('click', markerRouteSelectHandler);
              });
            }
          });
          document.getElementById("scheduleContainer").style.display = "block";
          renderPreviewBlock();
        }
      } else {
        removePreviewBlocks();
      }
    });
    
    // Day-of-week mapping and grid time parameters.
    const dayIndexMap = {
      M: 0,
      Tu: 1,
      W: 2,
      Th: 3,
      F: 4
    };
    const startHour = 7;
    const endHour = 18;
    
    // Updated parseTime: if hour < 7, assume PM.
    function parseTime(timeStr) {
      if (!timeStr) return null;
      const parts = timeStr.split(':');
      if (parts.length !== 2) return null;
      let hour = parseInt(parts[0], 10);
      const minute = parseInt(parts[1], 10);
      if (hour < 7) {
        hour += 12;
      }
      return hour + (minute / 60);
    }
    
    function initializeScheduleGrid() {
      const scheduleGrid = document.getElementById('scheduleGrid');
      for (let hour = startHour; hour < endHour; hour++) {
        const timeLabel = document.createElement('div');
        timeLabel.className = 'time-label';
        const ampm = (hour < 12) ? 'AM' : 'PM';
        const displayHour = (hour % 12 === 0) ? 12 : (hour % 12);
        timeLabel.textContent = `${displayHour} ${ampm}`;
        scheduleGrid.appendChild(timeLabel);
        for (let d = 0; d < 5; d++) {
          const cell = document.createElement('div');
          cell.className = 'schedule-cell';
          scheduleGrid.appendChild(cell);
        }
      }
    }
    initializeScheduleGrid();
    
    // Render saved course blocks (final, with opacity 0.8).
    function renderSchedule() {
      document.querySelectorAll('.saved-block').forEach(block => block.remove());
      const scheduleGridEl = document.getElementById('scheduleGrid');
      const gridWidth = scheduleGridEl.clientWidth;
      const timeLabelWidth = 50;
      const totalGaps = 4;
      const dayColWidth = (gridWidth - timeLabelWidth - totalGaps) / 5;
      for (let key of addedCourses) {
        const sectionObj = savedSectionsData[key];
        if (!sectionObj) continue;
        const courseId = key.split('-')[0];
        if (!courseColorMapping[courseId]) {
          courseColorMapping[courseId] = availableColors[nextColorIndex];
          nextColorIndex = (nextColorIndex + 1) % availableColors.length;
        }
        const assignedColor = courseColorMapping[courseId];
        const hexColor = colorHexMapping[assignedColor] || 'black';
        sectionObj.meetings.forEach(meeting => {
          const daysStr = meeting.days;
          const startT = parseTime(meeting.start_time);
          const endT = parseTime(meeting.end_time);
          if (!daysStr || !startT || !endT) return;
          let dayTokens = parseDays(daysStr);
          dayTokens.forEach(day => {
            const colIndex = dayIndexMap[day];
            if (colIndex === undefined) return;
            const startOffset = ((startT - startHour) + 1) * 31;
            const blockHeight = (endT - startT) * 31;
            const leftOffset = timeLabelWidth + colIndex * (dayColWidth + 1) + 3.5;
            const block = document.createElement('div');
            block.className = 'schedule-block saved-block';
            block.style.backgroundColor = hexColor;
            block.style.opacity = "0.8";
            block.style.top = `${startOffset}px`;
            block.style.left = `${leftOffset}px`;
            block.style.height = `${blockHeight}px`;
            block.style.width = `${dayColWidth - 6}px`;
            scheduleGridEl.appendChild(block);
          });
        });
      }
    }
    
    // Render preview block for courses (with opacity 0.5).
    function renderPreviewBlock() {
      removePreviewBlocks();
      const sectionId = sectionSelect.value;
      if (!sectionId) return;
      const sectionObj = currentSections.find(s => s.section_id === sectionId);
      if (!sectionObj) return;
      const scheduleGridEl = document.getElementById('scheduleGrid');
      const gridWidth = scheduleGridEl.clientWidth;
      const timeLabelWidth = 50;
      const totalGaps = 4;
      const dayColWidth = (gridWidth - timeLabelWidth - totalGaps) / 5;
      const courseId = searchBar.value.trim();
      if (!courseId) return;
      if (!courseColorMapping[courseId]) {
        courseColorMapping[courseId] = availableColors[nextColorIndex];
        nextColorIndex = (nextColorIndex + 1) % availableColors.length;
      }
      const assignedColor = courseColorMapping[courseId];
      const hexColor = colorHexMapping[assignedColor] || 'black';
      const conflict = hasTimeConflict(sectionObj);
      sectionObj.meetings.forEach(meeting => {
        const daysStr = meeting.days;
        const startT = parseTime(meeting.start_time);
        const endT = parseTime(meeting.end_time);
        if (!daysStr || !startT || !endT) return;
        let dayTokens = parseDays(daysStr);
        dayTokens.forEach(day => {
          const colIndex = dayIndexMap[day];
          if (colIndex === undefined) return;
          const startOffset = ((startT - startHour) + 1) * 31;
          const blockHeight = (endT - startT) * 31;
          const leftOffset = timeLabelWidth + colIndex * (dayColWidth + 1) + 3.5;
          const block = document.createElement('div');
          block.className = 'schedule-block preview-block';
          block.style.backgroundColor = hexColor;
          block.style.opacity = "0.5";
          block.style.top = `${startOffset}px`;
          block.style.left = `${leftOffset}px`;
          block.style.height = `${blockHeight}px`;
          block.style.width = `${dayColWidth - 6}px`;
          if (conflict) {
            const conflictIndicator = document.createElement('div');
            conflictIndicator.className = 'conflict-indicator';
            conflictIndicator.textContent = "!";
            block.appendChild(conflictIndicator);
          }
          scheduleGridEl.appendChild(block);
        });
      });
    }
    
    function removePreviewBlocks() {
      document.querySelectorAll('.preview-block').forEach(block => block.remove());
    }
    
    // --- TIMED ENTRY PREVIEW LOGIC ---
    const timedEntryForm = document.getElementById("timedEntryForm");
    const addEntryButton = timedEntryForm.querySelector("button[type='submit']");
    const clearEntryButton = document.getElementById("clearEntryButton");
    
    function updateTimedEntryPreview() {
      document.querySelectorAll('.timed-entry-preview').forEach(block => block.remove());
      const daysEls = timedEntryForm.querySelectorAll("input[name='day']:checked");
      const startTimeEl = timedEntryForm.querySelector("input[name='startTime']");
      const endTimeEl = timedEntryForm.querySelector("input[name='endTime']");
      if (daysEls.length === 0 || !startTimeEl.value || !endTimeEl.value) {
        addEntryButton.disabled = true;
        return;
      }
      const daysArr = Array.from(daysEls).map(el => el.value);
      const candidate = {
        days: daysArr.join(""),
        start_time: startTimeEl.value,
        end_time: endTimeEl.value
      };
      const conflict = hasConflictForTimedEntry(candidate);
      addEntryButton.disabled = conflict;
      const scheduleGridEl = document.getElementById('scheduleGrid');
      const gridWidth = scheduleGridEl.clientWidth;
      const timeLabelWidth = 50;
      const totalGaps = 4;
      const dayColWidth = (gridWidth - timeLabelWidth - totalGaps) / 5;
      const startT = parseTime(candidate.start_time);
      const endT = parseTime(candidate.end_time);
      daysArr.forEach(day => {
        const colIndex = dayIndexMap[day];
        if (colIndex === undefined) return;
        const startOffset = ((startT - startHour) + 1) * 31;
        const blockHeight = (endT - startT) * 31;
        const leftOffset = timeLabelWidth + colIndex * (dayColWidth + 1) + 3.5;
        const block = document.createElement('div');
        block.className = 'schedule-block timed-entry-preview';
        block.style.backgroundColor = "#3388ff";
        block.style.opacity = "0.5";
        block.style.top = `${startOffset}px`;
        block.style.left = `${leftOffset}px`;
        block.style.height = `${blockHeight}px`;
        block.style.width = `${dayColWidth - 6}px`;
        if (conflict) {
          const conflictIndicator = document.createElement('div');
          conflictIndicator.className = 'conflict-indicator';
          conflictIndicator.textContent = "!";
          block.appendChild(conflictIndicator);
        }
        scheduleGridEl.appendChild(block);
      });
    }
    
    document.querySelectorAll("#timedEntryForm input").forEach(input => {
      input.addEventListener("input", updateTimedEntryPreview);
      input.addEventListener("change", updateTimedEntryPreview);
    });
    
    clearEntryButton.addEventListener("click", function(){
      timedEntryForm.reset();
      document.querySelectorAll('.timed-entry-preview').forEach(block => block.remove());
      timedEntries = [];
      renderTimedEntries();
      addEntryButton.disabled = true;
    });
    
    timedEntryForm.addEventListener("submit", function(e) {
      e.preventDefault();
      const formData = new FormData(this);
      const daysArr = formData.getAll("day");
      if (daysArr.length === 0) {
        alert("Please select at least one day.");
        return;
      }
      const candidate = { days: daysArr.join(""), start_time: formData.get("startTime"), end_time: formData.get("endTime") };
      if (!candidate.start_time || !candidate.end_time) {
        alert("Please enter start and end times.");
        return;
      }
      if (hasConflictForTimedEntry(candidate)) {
        alert("Timed entry conflicts with an existing event. Cannot add entry.");
        return;
      }
      timedEntries.push(candidate);
      renderTimedEntries();
      document.querySelectorAll('.timed-entry-preview').forEach(block => block.remove());
      this.reset();
      addEntryButton.disabled = true;
    });
    
    function renderTimedEntries() {
      const scheduleGridEl = document.getElementById('scheduleGrid');
      document.querySelectorAll('.timed-entry-block').forEach(block => block.remove());
      const gridWidth = scheduleGridEl.clientWidth;
      const timeLabelWidth = 50;
      const totalGaps = 4;
      const dayColWidth = (gridWidth - timeLabelWidth - totalGaps) / 5;
      timedEntries.forEach(entry => {
        const entryDays = parseDays(entry.days);
        const startT = parseTime(entry.start_time);
        const endT = parseTime(entry.end_time);
        const conflict = hasConflictForTimedEntry(entry);
        entryDays.forEach(day => {
          const colIndex = dayIndexMap[day];
          if (colIndex === undefined) return;
          const startOffset = ((startT - startHour) + 1) * 31;
          const blockHeight = (endT - startT) * 31;
          const leftOffset = timeLabelWidth + colIndex * (dayColWidth + 1) + 3.5;
          const block = document.createElement('div');
          block.className = 'schedule-block timed-entry-block';
          block.style.backgroundColor = "#3388ff";
          block.style.opacity = "0.8";
          block.style.top = `${startOffset}px`;
          block.style.left = `${leftOffset}px`;
          block.style.height = `${blockHeight}px`;
          block.style.width = `${dayColWidth - 6}px`;
          if (conflict) {
            const conflictIndicator = document.createElement('div');
            conflictIndicator.className = 'conflict-indicator';
            conflictIndicator.textContent = "!";
            block.appendChild(conflictIndicator);
          }
          scheduleGridEl.appendChild(block);
        });
      });
    }
    
    // Add course and force saved courses container to show.
    addBtn.addEventListener("click", () => {
      const courseId = searchBar.value.trim();
      const sectionId = sectionSelect.value.trim();
      if (!courseId || !sectionId) return;
      const key = courseId + "-" + sectionId;
      const sectionObj = currentSections.find(s => s.section_id === sectionId);
      if (!sectionObj) return;
      if (hasTimeConflict(sectionObj)) {
        alert("Time conflict: this course overlaps with an existing saved course or custom timed entry.");
        return;
      }
      if (addedCourses.size >= 8) {
        alert("Maximum saved courses reached (8).");
        return;
      }
      if (addedCourses.has(key)) return;
      if (activeMarkers.getLayers().length === 0 && sectionSelect.value) {
        sectionSelect.dispatchEvent(new Event('change'));
      }
      savedSectionsData[key] = sectionObj;
      const courseLayerGroup = L.layerGroup();
      activeMarkers.eachLayer(layer => {
        const pos = layer.getLatLng();
        const icon = layer.options.icon;
        const popup = layer.getPopup() ? layer.getPopup().getContent() : "";
        let clonedMarker = L.marker(pos, {icon: icon, zIndexOffset: markerZIndexCounter++});
        if (popup) {
          clonedMarker.bindPopup(popup);
        }
        // Attach route select handler to cloned markers as well.
        clonedMarker.on('click', markerRouteSelectHandler);
        courseLayerGroup.addLayer(clonedMarker);
      });
      courseLayerGroup.addTo(map);
      savedCourseMarkerGroups[key] = courseLayerGroup;
      addedCourses.add(key);
      savedCoursesDiv.style.display = "block";
      let courseItem = document.createElement("div");
      courseItem.className = "saved-course-item";
      let infoDiv = document.createElement("div");
      infoDiv.className = "course-info";
      let legendBox = document.createElement("span");
      legendBox.className = "color-legend";
      const assignedColor = courseColorMapping[courseId] || "black";
      const hexColor = colorHexMapping[assignedColor] || "black";
      legendBox.style.backgroundColor = hexColor;
      let displayText = sectionId && sectionId.startsWith(courseId + "-")
            ? sectionId
            : `${courseId}-${sectionId}`;
      let textSpan = document.createElement("span");
      textSpan.textContent = displayText;
      infoDiv.appendChild(legendBox);
      infoDiv.appendChild(textSpan);
      let controlsDiv = document.createElement("div");
      controlsDiv.className = "course-controls";
      let checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = true;
      // When checked, update the markers’ z-index to bring them to top.
      checkbox.addEventListener("change", () => {
        if (checkbox.checked) {
          courseLayerGroup.eachLayer(layer => {
            layer.setZIndexOffset(++markerZIndexCounter);
          });
          courseLayerGroup.addTo(map);
        } else {
          map.removeLayer(courseLayerGroup);
        }
      });
      let removeBtn = document.createElement("button");
      removeBtn.textContent = "✕";
      removeBtn.style.fontSize = "0.8em";
      removeBtn.addEventListener("click", () => {
        map.removeLayer(courseLayerGroup);
        courseListDiv.removeChild(courseItem);
        delete savedCourseMarkerGroups[key];
        addedCourses.delete(key);
        delete savedSectionsData[key];
        renderSchedule();
      });
      controlsDiv.appendChild(checkbox);
      controlsDiv.appendChild(removeBtn);
      courseItem.appendChild(infoDiv);
      courseItem.appendChild(controlsDiv);
      courseListDiv.appendChild(courseItem);
      activeMarkers.clearLayers();
      removePreviewBlocks();
      renderSchedule();
    });
    
    removeAllBtn.addEventListener("click", () => {
      Object.values(savedCourseMarkerGroups).forEach(layerGroup => {
        map.removeLayer(layerGroup);
      });
      courseListDiv.innerHTML = "";
      for (let key in savedCourseMarkerGroups) {
        delete savedCourseMarkerGroups[key];
      }
      addedCourses.clear();
      for (let k in savedSectionsData) {
        delete savedSectionsData[k];
      }
      renderSchedule();
    });
    
    // Draggable containers
    let highestZIndex = 11000;
    function makeDraggable(el) {
      let isDragging = false;
      let startX, startY;
      el.addEventListener("mousedown", function(e) {
        highestZIndex++;
        el.style.setProperty("z-index", highestZIndex, "important");
        isDragging = true;
        startX = e.clientX - el.offsetLeft;
        startY = e.clientY - el.offsetTop;
        
        el.style.cursor = "move";
      });
      document.addEventListener("mousemove", function(e) {
        if (isDragging) {
          el.style.left = (e.clientX - startX) + "px";
          el.style.top = (e.clientY - startY) + "px";
        }
      });
      document.addEventListener("mouseup", function() {
        if (isDragging) {
          isDragging = false;
          el.style.cursor = "default";
        }
      });
    }
    makeDraggable(document.getElementById("savedCourses"));
    makeDraggable(document.getElementById("scheduleContainer"));
    makeDraggable(document.getElementById("routeContainer"));
    makeDraggable(document.getElementById("busRoutesContainer"));

document.getElementById("closeBusRoutes").addEventListener("click", () => {
  document.getElementById("busRoutesContainer").style.display = "none";
});
    
    menuIcon.addEventListener("click", (e) => {
      e.stopPropagation();
      dropdownMenu.classList.toggle("open");
    });
    document.querySelectorAll(".dropdown-menu .menu-item").forEach(item => {
      item.addEventListener("click", () => {
        const targetId = item.getAttribute("data-target");
        const targetEl = document.getElementById(targetId);

        if (targetId === "savedCourses") {
          targetEl.style.top = "-10px";
          targetEl.style.left = "-220px";
          targetEl.style.right = "";
        } else if (targetId === "scheduleContainer") {
          targetEl.style.top = "220px";
          targetEl.style.left = "-300px";
          targetEl.style.right = "";
        } else if (targetId === "routeContainer") {
          targetEl.style.top = "-20px";
          targetEl.style.right = "-270px";
          targetEl.style.left = "";
        }else if (targetId === "busRoutesContainer") {
      // Adjusted position for bus routes container:
      targetEl.style.top = "195px";
      targetEl.style.right = "-250px";
      targetEl.style.left = "";
    } 
        targetEl.style.display = "block";
        dropdownMenu.classList.remove("open");
      });
    });
    closeSavedCourses.addEventListener("click", () => {
      savedCoursesDiv.style.display = "none";
    });
    closeSchedule.addEventListener("click", () => {
      document.getElementById("scheduleContainer").style.display = "none";
    });
    const closeRoutePlanner = document.getElementById('closeRoutePlanner');
    closeRoutePlanner.addEventListener("click", () => {
      document.getElementById("routeContainer").style.display = "none";
    });
    
    // Timed Entry window events
    const openTimedEntry = document.getElementById("openTimedEntry");
    const timedEntryWindow = document.getElementById("timedEntryWindow");
    const closeTimedEntry = document.getElementById("closeTimedEntry");
    openTimedEntry.addEventListener("click", () => {
      timedEntryWindow.style.display = "block";
    });
    // When closing, reset form, remove schedule preview blocks and timed entry preview blocks.
    closeTimedEntry.addEventListener("click", () => {
      timedEntryWindow.style.display = "none";
      timedEntryForm.reset();
      document.querySelectorAll('.timed-entry-preview').forEach(block => block.remove());
    });
    makeDraggable(timedEntryWindow);
    
    
    // --- ROUTE PLANNER LOGIC ---
    const transportModesEl = document.getElementById('transportModes');
    const planRouteBtn = document.getElementById('planRouteBtn');
    let selectedMode = 'drive'; // default mode
    
    transportModesEl.addEventListener('click', (e) => {
      if (e.target && e.target.dataset.mode) {
        // Remove the 'selected' class from all icons and add it to the clicked icon
        transportModesEl.querySelectorAll('i').forEach(icon => icon.classList.remove('selected'));
        e.target.classList.add('selected');
        selectedMode = e.target.dataset.mode;
      }
    });
    
    document.getElementById('addStop').addEventListener('click', () => {
  // Ensure that both start point and primary destination are filled before allowing stops to be added.
  if (!startLocationInput.value.trim() || !endLocationInput.value.trim()) {
    alert("Please fill in both start point and destination before adding stops.");
    return;
  }
  
  const routeInputs = document.querySelector('#routeContainer .route-inputs');
  
  // Check if there is already an empty destination input (i.e. a stop that hasn't been filled).
  const emptyInput = Array.from(routeInputs.querySelectorAll('input.destination-input')).find(input => input.value.trim() === "");
  if (emptyInput) {
    alert("Please fill in the current stop before adding a new one.");
    return;
  }
  
  // Optional: Enforce a maximum number of stops (if desired, here up to 3).
  const currentDestinations = routeInputs.querySelectorAll('input.destination-input').length;
  if (currentDestinations >= 5) {
    alert("Maximum of 5 stops reached.");
    return;
  }
  
  // Create a new destination input.
  const newDestinationInput = document.createElement('input');
  newDestinationInput.type = 'text';
  newDestinationInput.className = 'destination-input';
  newDestinationInput.placeholder = "Choose Destination";
  newDestinationInput.autocomplete = "off";
  
  // Attach a focus event listener so that clicking on marker pins can set its value automatically.
  newDestinationInput.addEventListener('focus', function() {
    // Remove active-route-input class from all route inputs.
    document.querySelectorAll('#routeContainer .route-inputs input').forEach(input => input.classList.remove('active-route-input'));
    activeRouteInput = newDestinationInput;
    newDestinationInput.classList.add('active-route-input');
  });
  
  // Append the new destination input to the route-inputs container.
  routeInputs.appendChild(newDestinationInput);
});
   
    
  async function computeRoute(origin, destination, travelMode = "DRIVE") {
  const apiKey = 'AIzaSyAS3arcO-QbiYM1cgaxgegiTbBnkM5d-OY'; // Replace with your API key.
  const url = 'https://routes.googleapis.com/directions/v2:computeRoutes';

  // Build the base request body.
  const requestBody = {
    origin: {
      location: {
        latLng: {
          latitude: origin.lat,
          longitude: origin.lng
        }
      }
    },
    destination: {
      location: {
        latLng: {
          latitude: destination.lat,
          longitude: destination.lng
        }
      }
    },
    travelMode: travelMode,
    computeAlternativeRoutes: false,
    routeModifiers: {
      avoidTolls: false,
      avoidHighways: false,
      avoidFerries: false
    },
    languageCode: "en-US",
    units: "IMPERIAL"
  };

  // For driving routes, use traffic-aware preference.
  if (travelMode === "DRIVE") {
    requestBody.routingPreference = "TRAFFIC_AWARE";
  } else {
    // For non-driving modes, you might not want traffic info.
    // In addition, transit mode usually requires a departure time.
    if (travelMode === "TRANSIT") {
      requestBody.departureTime = new Date().toISOString();
    }
    // Remove routingPreference if present.
  }

  try {
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Goog-Api-Key': apiKey,
        'X-Goog-FieldMask': 'routes.duration,routes.distanceMeters,routes.polyline.encodedPolyline'
      },
      body: JSON.stringify(requestBody)
    });
    if (!response.ok) {
      throw new Error(`Routes API request failed: ${response.statusText}`);
    }
    const data = await response.json();
    return data;
  } catch (error) {
    console.error("Error computing route:", error);
    alert("Route computation failed: " + error.message);
  }
}

// Update the plan route button event listener.
planRouteBtn.addEventListener('click', async () => {
  // Gather all route input fields (start point and all destination inputs)
  const routeInputs = document.querySelectorAll('#routeContainer .route-inputs input');
  let points = [];
  for (let input of routeInputs) {
    const val = input.value.trim();
    if (!val) {
      alert("Please fill all route points.");
      return;
    }
    const parts = val.split(',');
    if (parts.length !== 2) {
      alert("Invalid coordinate format. Please use 'lat, lng'.");
      return;
    }
    let lat = parseFloat(parts[0].trim());
    let lng = parseFloat(parts[1].trim());
    if (isNaN(lat) || isNaN(lng)) {
      alert("Invalid coordinates provided.");
      return;
    }
    points.push({ lat, lng });
  }
  if (points.length < 2) {
    alert("At least two route points are required.");
    return;
  }
  
  // Determine travel mode based on selected mode (mapping to API expected values)
  let travelMode;
  switch(selectedMode) {
    case 'transit':
      travelMode = "TRANSIT";
      break;
    case 'walking':
      travelMode = "WALK";
      break;
    case 'bicycling':
      travelMode = "BICYCLE";
      break;
    case 'drive':
    default:
      travelMode = "DRIVE";
  }
  

  // Variables to accumulate route data.
  let masterRouteCoords = [];
  let totalDurationSeconds = 0;
  let totalDistanceMeters = 0;
  
  // Loop through each consecutive pair of points to compute route segments.
  for (let i = 0; i < points.length - 1; i++) {
    const origin = points[i];
    const destination = points[i + 1];
    const segmentResponse = await computeRoute(origin, destination, travelMode);
    if (segmentResponse && segmentResponse.routes && segmentResponse.routes.length > 0) {
      const routeSegment = segmentResponse.routes[0];
      
      // Process duration for this segment.
      let rawDuration = routeSegment.duration;
      if (typeof rawDuration === "string") {
        rawDuration = rawDuration.replace(/[^0-9.]/g, "");
      }
      const segmentDurationSeconds = parseFloat(rawDuration) || 0;
      totalDurationSeconds += segmentDurationSeconds;
      
      // Process distance for this segment.
      totalDistanceMeters += routeSegment.distanceMeters || 0;
      
      // Decode the polyline for this segment.
      const encodedPolyline = routeSegment.polyline.encodedPolyline;
      const decodedPath = google.maps.geometry.encoding.decodePath(encodedPolyline);
      let segmentCoords = decodedPath.map(latlng => [latlng.lat(), latlng.lng()]);
      
      // Remove duplicate connecting point if present.
      if (i > 0 && masterRouteCoords.length > 0) {
        const lastCoord = masterRouteCoords[masterRouteCoords.length - 1];
        const firstCoord = segmentCoords[0];
        if (Math.abs(lastCoord[0] - firstCoord[0]) < 1e-6 &&
            Math.abs(lastCoord[1] - firstCoord[1]) < 1e-6) {
          segmentCoords.shift();
        }
      }
      masterRouteCoords = masterRouteCoords.concat(segmentCoords);
    } else {
      alert("No route found for segment " + (i + 1));
      return;
    }
  }
  
  // Remove any existing route polyline.
  if (routePolyline) {
    map.removeLayer(routePolyline);
  }
  
  // Create one combined polyline for the multi-stop route.
  routePolyline = L.polyline(masterRouteCoords, { color: '#3388ff', weight: 6, opacity: 0.8 }).addTo(map);
  
  // Format total duration.
  const hours = Math.floor(totalDurationSeconds / 3600);
  const minutes = Math.floor((totalDurationSeconds % 3600) / 60);
  const durationText = hours > 0 ? `${hours} hr ${minutes} min` : `${minutes} min`;
  
  // Format total distance.
  const distanceKm = (totalDistanceMeters / 1000).toFixed(2);
  const distanceMiles = (totalDistanceMeters / 1609.34).toFixed(2);
  
  // Keep your current popup message format.
  const modeNames = {
    drive: "Driving",
    transit: "Transit",
    walking: "Walking",
    bicycling: "Bicycling"
  };
  const modeDisplay = modeNames[selectedMode] || selectedMode;
  
  const popupMessage = `
      <strong>Mode:</strong> ${modeDisplay}<br>
      <strong>Duration:</strong> ${durationText}<br>
      <strong>Distance:</strong> ${distanceKm} km / ${distanceMiles} mi
    `;
  
  // Bind the popup message to the combined polyline and open it.
  routePolyline.bindPopup(popupMessage).openPopup();
});

let busRoutesState = {};

function showBusRouteSchedule(routeId) {
  // Get the bus routes container element and store its default HTML
  const busRoutesContainer = document.getElementById('busRoutesContainer');
  const busRoutesDefaultHTML = busRoutesContainer.innerHTML;
  // Clear its current content
  busRoutesContainer.innerHTML = '';

  // Create and append a close button to hide the bus routes container
  const backBtn = document.createElement('div');
backBtn.id = 'backBtn';
backBtn.textContent = '< Back';
// Let the button size naturally and center its text
backBtn.style.display = 'inline-block';
backBtn.style.textAlign = 'center';
// Reduced padding for a smaller button
backBtn.style.padding = '3px 6px';
backBtn.style.marginBottom = '10px';
// Smaller font size
backBtn.style.fontSize = '14px';
backBtn.style.fontWeight = 'bold';
// Use UMD red for text and border
backBtn.style.color = '#e21833';
backBtn.style.border = '1px solid #e21833';
// Contrasting background and rounded corners
backBtn.style.backgroundColor = '#fff';
backBtn.style.borderRadius = '4px';
// Smaller box shadow
backBtn.style.boxShadow = '0 1px 2px rgba(0, 0, 0, 0.15)';
// Set cursor to pointer
backBtn.style.cursor = 'pointer';

  // Create and append a back button to return to the original bus routes page
  
  backBtn.addEventListener('click', () => {
    // Restore the default HTML for the bus routes container.
    busRoutesContainer.innerHTML = busRoutesDefaultHTML;
    
    // Reattach event listeners for hide all and show all buttons.
    document.getElementById("hideAllRoutes").addEventListener("click", function() {
      Object.keys(busRoutesLayers).forEach(routeId => {
        busRoutesLayers[routeId].forEach(layer => {
          map.removeLayer(layer);
        });
      }); 
      Object.keys(busStopMarkers).forEach(routeId => {
        busStopMarkers[routeId].forEach(marker => {
          map.removeLayer(marker);
        });
      });
      document.querySelectorAll('#busRoutesList input[type="checkbox"]').forEach(checkbox => {
        checkbox.checked = false;
      });
    });
    document.getElementById("showAllRoutes").addEventListener("click", function() {
      Object.keys(busRoutesLayers).forEach(routeId => {
        busRoutesLayers[routeId].forEach(layer => {
          layer.addTo(map);
        });
      });
      Object.keys(busStopMarkers).forEach(routeId => {
        busStopMarkers[routeId].forEach(marker => {
          marker.addTo(map);
        });
      });
      document.querySelectorAll('#busRoutesList input[type="checkbox"]').forEach(checkbox => {
        checkbox.checked = true;
      });
    });

    document.getElementById("closeBusRoutes").addEventListener("click", () => {
    busRoutesContainer.style.display = "none";
  });
    
    // Repopulate the bus routes list so that checkbox states are restored.
    populateBusRoutesList();
    
    // Ensure the container is visible.
    busRoutesContainer.style.display = 'block';
  });
  busRoutesContainer.appendChild(backBtn);

  // Append a title for the bus schedule interface with the route ID
  const title = document.createElement('h3');
  title.textContent = 'Schedule for Route ' + routeId;
  busRoutesContainer.appendChild(title);

  // Create the form for selecting bus day and direction
  const optionsDiv = document.createElement('div');
  optionsDiv.id = 'busRouteOptions';
  optionsDiv.style.marginTop = '10px';
  optionsDiv.style.marginBottom = '5px';

  const form = document.createElement('form');
  form.id = 'busRouteOptionsForm';

  // Day selection (radio buttons for Mon to Fri)
  const daySelectionDiv = document.createElement('div');
  daySelectionDiv.className = 'day-selection';
  daySelectionDiv.style.display = 'flex';
  daySelectionDiv.style.justifyContent = 'center';
  daySelectionDiv.style.gap = '10px';
  daySelectionDiv.style.marginBottom = '10px';

  ['M', 'Tu', 'W', 'Th', 'F'].forEach(day => {
    const label = document.createElement('label');
    label.className = 'day-label';
    const radio = document.createElement('input');
    radio.type = 'radio';
    radio.name = 'busDay';
    radio.value = day;
    if (day === 'M') {
      radio.checked = true;
    }
    label.appendChild(radio);
    label.appendChild(document.createTextNode(' ' + day));
    daySelectionDiv.appendChild(label);
  });

  // Direction selection (radio buttons for Inbound and Outbound)
  const directionSelectionDiv = document.createElement('div');
  directionSelectionDiv.className = 'direction-selection';
  directionSelectionDiv.style.display = 'flex';
  directionSelectionDiv.style.justifyContent = 'center';
  directionSelectionDiv.style.gap = '10px';

  const inboundLabel = document.createElement('label');
  inboundLabel.className = 'direction-label';
  const inboundRadio = document.createElement('input');
  inboundRadio.type = 'radio';
  inboundRadio.name = 'busDirection';
  inboundRadio.value = 'inbound';
  inboundRadio.checked = true;
  inboundLabel.appendChild(inboundRadio);
  inboundLabel.appendChild(document.createTextNode(' Inbound'));
  directionSelectionDiv.appendChild(inboundLabel);

  const outboundLabel = document.createElement('label');
  outboundLabel.className = 'direction-label';
  const outboundRadio = document.createElement('input');
  outboundRadio.type = 'radio';
  outboundRadio.name = 'busDirection';
  outboundRadio.value = 'outbound';
  outboundLabel.appendChild(outboundRadio);
  outboundLabel.appendChild(document.createTextNode(' Outbound'));
  directionSelectionDiv.appendChild(outboundLabel);

  // Append the day and direction selections to the form
  form.appendChild(daySelectionDiv);
  form.appendChild(directionSelectionDiv);
  optionsDiv.appendChild(form);

  // Append the options form to the bus routes container
  busRoutesContainer.appendChild(optionsDiv);

  // Create a container for displaying the bus routes schedule details
  const routesListDiv = document.createElement('div');
  routesListDiv.id = 'busRoutesList';
  routesListDiv.style.marginTop = '10px';
  busRoutesContainer.appendChild(routesListDiv);

  // --- Integrated Schedule Display ---
  // --- Integrated Schedule Display ---
// Function to update the bus schedule list based on selected day and direction
function updateBusRoutesList() {
  // Define day mapping: user selections (M, Tu, W, Th, F) to dataset labels ("mtw", "th", "f")
  const dayMapping = {
    "M": "mtw",
    "Tu": "mtw",
    "W": "mtw",
    "Th": "th",
    "F": "f"
  };

  // Retrieve selected day and direction from radio buttons
  const dayRadio = document.querySelector('input[name="busDay"]:checked');
  const directionRadio = document.querySelector('input[name="busDirection"]:checked');
  const selectedDay = dayRadio ? dayRadio.value : "";
  const mappedDay = dayMapping[selectedDay] || "";
  const selectedDirection = directionRadio ? directionRadio.value : "";

  // Clear the routes list container
  routesListDiv.innerHTML = "";

  if (!window.filteredBusSchedule) {
    routesListDiv.innerHTML = "<p>Schedule data not loaded.</p>";
    return;
  }

  // Filter schedule data by routeId and mapped day (checks if schedule.days contains the mappedDay)
  let filteredData = window.filteredBusSchedule.filter(schedule => {
    return schedule.route === routeId && (!mappedDay || schedule.days.indexOf(mappedDay) !== -1);
  });

  // Adjust for direction: assume first record is outbound and second is inbound
  if (selectedDirection) {
    if (selectedDirection === "outbound") {
      filteredData = filteredData.slice(0, 1);
    } else if (selectedDirection === "inbound") {
      filteredData = filteredData.slice(1, 2);
    }
  }

  if (filteredData.length === 0) {
    routesListDiv.innerHTML = "<p>No schedule found.</p>";
    return;
  }

  // For each matching schedule record, parse stops and trips, then display schedule details
  filteredData.forEach(schedule => {
    let stops, trips;
    try {
     
      const sanitizedStops = schedule.stops.replace(/'/g, '"').trim();
      const sanitizedTrips = schedule.trips.replace(/'/g, '"').trim();
      stops = JSON.parse(sanitizedStops);
      trips = JSON.parse(sanitizedTrips);
  
    } catch (error) {
      console.error('Error parsing stops or trips for schedule:', schedule, error);
      return;
    }

    // Create a container for this schedule entry
  const entryContainer = document.createElement('div');
  entryContainer.style.marginBottom = '10px';

  // Create and append a label above the stop selector
  const stopLabel = document.createElement('div');
  stopLabel.textContent = "Stop:";
  stopLabel.style.fontWeight = "bold";
  stopLabel.style.marginBottom = "4px";
  entryContainer.appendChild(stopLabel);

  // Create a stop selector dropdown
  const stopSelector = document.createElement('select');
  stopSelector.style.width = "200px";
  stops.forEach((stop, index) => {
    const option = document.createElement('option');
    option.value = index;
    option.textContent = stop.name.replace(/"/g, "'");
    stopSelector.appendChild(option);
  });
  entryContainer.appendChild(stopSelector);

  // Create a div to display schedule details for the selected stop
  const scheduleDisplay = document.createElement('div');
  entryContainer.appendChild(scheduleDisplay);

  // Function to update schedule details based on the selected stop
  function updateStopSchedule() {
    const selectedStopIndex = parseInt(stopSelector.value) || 0;
    // Extract arrival times for the selected stop from each trip
    const arrivalTimes = trips.map(trip => (trip && trip[selectedStopIndex] && trip[selectedStopIndex].arrival_time) || "").filter(Boolean);
    const groupedTimes = {};
    arrivalTimes.forEach(time => {
      const hour = time.split(":")[0];
      if (!groupedTimes[hour]) {
        groupedTimes[hour] = [];
      }
      groupedTimes[hour].push(time);
    });
    const formattedTimes = Object.keys(groupedTimes)
      .sort()
      .map(hour => groupedTimes[hour].join(", "))
      .join("<br>");

    scheduleDisplay.innerHTML = "";

    // Create the arrival times label element with the same styling as the stop label
  const arrivalLabel = document.createElement('div');
  arrivalLabel.textContent = "Arrival Times:";
  arrivalLabel.style.fontWeight = "bold";
  arrivalLabel.style.marginTop = "10px";
  arrivalLabel.style.marginBottom = "4px";
  scheduleDisplay.appendChild(arrivalLabel);

  const arrivalContent = document.createElement('div');
  arrivalContent.innerHTML = formattedTimes;
  scheduleDisplay.appendChild(arrivalContent);

  }

  // Initialize the schedule display for the default selected stop
  updateStopSchedule();
  // Update the schedule whenever the user selects a different stop
  stopSelector.addEventListener('change', updateStopSchedule);

  routesListDiv.appendChild(entryContainer);
});
}

  // Attach event listener to the options form to update the schedule list when selections change
  form.addEventListener('change', updateBusRoutesList);

  // Initial call to populate the schedule list with default selections
  updateBusRoutesList();

  // Ensure the container is visible
  busRoutesContainer.style.display = 'block';
}
function populateBusRoutesList() {
  const busRoutesListEl = document.getElementById('busRoutesList');
  busRoutesListEl.innerHTML = "";
  // Use flex layout with wrapping for two columns
  busRoutesListEl.style.display = "flex";
  busRoutesListEl.style.flexWrap = "wrap";

  Object.keys(busRoutesLayers).forEach(routeId => {
    const item = document.createElement('div');
    item.style.width = "50%"; // two columns
    item.style.boxSizing = "border-box";
    item.style.display = "flex";
    item.style.alignItems = "center";
    item.style.marginBottom = "5px";
    item.style.padding = "2px";
    
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.checked = (busRoutesState[routeId] === undefined ? true : busRoutesState[routeId]);
    checkbox.style.marginRight = '8px';

    // Toggle the corresponding bus route layers when the checkbox is changed.
    checkbox.addEventListener('change', function() {
      // Toggle route polyline layers.
      busRoutesLayers[routeId].forEach(layer => {
        if (checkbox.checked) {
          layer.addTo(map);
        } else {
          map.removeLayer(layer);
        }
      });
      // Toggle bus stop markers.
      if (busStopMarkers[routeId]) {
        busStopMarkers[routeId].forEach(marker => {
          if (checkbox.checked) {
            marker.addTo(map);
          } else {
            map.removeLayer(marker);
          }
        });
      }
       // Update the global state.
  busRoutesState[routeId] = checkbox.checked;
    });

    // Create a color swatch to visually indicate the route's unique color
    const colorSwatch = document.createElement('span');
    colorSwatch.style.display = 'inline-block';
    colorSwatch.style.width = '12px';
    colorSwatch.style.height = '12px';
    colorSwatch.style.borderRadius = '0';
    colorSwatch.style.backgroundColor = busRouteColorScale(routeId);
    colorSwatch.style.marginRight = '5px';
    
    const label = document.createElement('span');
    label.textContent = 'Route ' + routeId;
    // Also update the label text color to the unique color
    label.style.color = '#454545';
    // Make the label clickable to show the route schedule
    label.style.cursor = 'pointer';
    label.addEventListener('click', () => {
      showBusRouteSchedule(routeId);
    });
    
    item.appendChild(checkbox);
    item.appendChild(colorSwatch);
    item.appendChild(label);
    
    busRoutesListEl.appendChild(item);
  });
}


document.getElementById("hideAllRoutes").addEventListener("click", function() {
  Object.keys(busRoutesLayers).forEach(routeId => {
    busRoutesState[routeId] = false;
    busRoutesLayers[routeId].forEach(layer => {
      map.removeLayer(layer);
    });
  });
  Object.keys(busStopMarkers).forEach(routeId => {
    busStopMarkers[routeId].forEach(marker => {
      map.removeLayer(marker);
    });
  });
  // Update all checkboxes to unchecked
  document.querySelectorAll('#busRoutesList input[type="checkbox"]').forEach(checkbox => {
    checkbox.checked = false;
  });
});

document.getElementById("showAllRoutes").addEventListener("click", function() {
  Object.keys(busRoutesLayers).forEach(routeId => {
    busRoutesState[routeId] = true;
    busRoutesLayers[routeId].forEach(layer => {
      layer.addTo(map);
    });
  });

  // Add all bus stop markers.
  Object.keys(busStopMarkers).forEach(routeId => {
    busStopMarkers[routeId].forEach(marker => {
      marker.addTo(map);
    });
  });
  // Update all checkboxes to checked
  document.querySelectorAll('#busRoutesList input[type="checkbox"]').forEach(checkbox => {
    checkbox.checked = true;
  });
});
  </script>

<script>
  // --- CSV Parsing Functions ---
  function parseCSVLine(text) {
    const result = [];
    let current = '';
    let insideQuotes = false;
    for (let i = 0; i < text.length; i++) {
      const char = text[i];
      if (char === '"') {
        if (insideQuotes && text[i + 1] === '"') {
          current += '"';
          i++; // skip escaped quote
        } else {
          insideQuotes = !insideQuotes;
        }
      } else if (char === ',' && !insideQuotes) {
        result.push(current);
        current = '';
      } else {
        current += char;
      }
    }
    result.push(current);
    return result.map(field => field.trim());
  }

  function parseCSV(csvText) {
    // Remove comment lines (starting with //)
    const lines = csvText.split('\n').filter(line => line.trim() && !line.trim().startsWith('//'));
    if (lines.length === 0) return [];
    const headers = parseCSVLine(lines[0]);
    const data = [];
    for (let i = 1; i < lines.length; i++) {
      const values = parseCSVLine(lines[i]);
      const obj = {};
      headers.forEach((header, index) => {
        obj[header] = values[index] || '';
      });
      data.push(obj);
    }
    return data;
  }

  // --- CSV Loader Function ---
  async function loadFilteredBusSchedules() {
    const response = await fetch('./data/filtered_bus_schedules.csv');
    const csvText = await response.text();
    return parseCSV(csvText);
  }

  async function loadBusSchedules() {
    try {
      const busSchedule = await loadFilteredBusSchedules();
      // Deduplicate the loaded data
      const dedupedSchedule = busSchedule.filter((item, index, self) =>
        index === self.findIndex(t => t.route === item.route && t.days === item.days && t.stops === item.stops)
      );
      window.filteredBusSchedule = dedupedSchedule;
      console.log('Loaded Filtered Bus Schedule Data:', dedupedSchedule);
    } catch (error) {
      console.error('Error loading filtered bus schedules:', error);
    }
  }

  // Initialize the filtered bus schedules load when the page loads
  loadBusSchedules();
</script>

  <div class="footer">
    <p>
      Contact us at 
      <a href="mailto:zai28@umd.edu">zai28@umd.edu</a> 
      | © 2025 University of Maryland
    </p>
  </div>
</body>
</html>